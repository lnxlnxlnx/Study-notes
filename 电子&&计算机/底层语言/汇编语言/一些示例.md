


### 说明
以下示例基于x86架构、DOS环境（使用MASM/TASM汇编器），覆盖汇编语言核心基础。每个程序包含代码注释、运行效果和知识点总结，适合初学者逐步掌握。

#### MOV AH，4CH 
是向A寄存器高字节ah赋值16进制数4c。  
此语句和int 21h 组合成一个完整的中断调用功能。  
int 表示中断，中断有很多种类，其中21h表示DOS系统的系统调用中断这一大类，下面还分了很多小类，小类的选择是放在ah寄存器中的。2个语句组合表示这个中断是21h大类中的4c小类。

#### 调用中断21h的4ch号功能。  
中断21h是DOS系统的系统调用中断，使用ah来选择功能。  
4ch号功能是退出程序的意思。  
  
==*21中断有很多功能.你要先把功能号放到AH寄存器.然后调用.*==21中断就会取功能号并根据功能号运行

**追问**

那这两行语句从上到下的顺序应该是反过来才对啊，先调用dos的代码，再决定用dos中的哪一种功能的代码。不是吗？

**追答**

不对.调用中断要先给参数.先压参数入寄存器然后中断自动看寄存器运行.这个比较简单就是退出.如果是其他功能.前面的语句会更多.


#### assume的作用
在汇编语言中，_assume_ 指令用于将段寄存器与特定的段名关联起来。这一指令告诉编译器在访问某个段中的变量时，应该使用哪个段寄存器作为段地址。_assume_ 指令本身并不会生成机器码，它只是为编译器提供信息，以便在编译过程中正确处理段寄存器和段名的关系。


### 示例1：两个8位无符号数相加（数据运算基础）
```asm
; ==============================================
; 功能：计算两个8位无符号数的和（结果不超过255）
; 输入：AL=第一个数（如0x30），BL=第二个数（如0x40）
; 输出：AX=和（0x70）
; ==============================================
CODE SEGMENT
    ASSUME CS:CODE          ; 关联段寄存器与逻辑段
START:
    MOV AL, 0x30            ; 立即寻址：将0x30（十进制48）存入AL
    MOV BL, 0x40            ; 立即寻址：将0x40（十进制64）存入BL
    ADD AL, BL              ; 算术指令：AL = AL + BL（结果0x70，即112）
    MOV AH, 4CH             ; 系统调用：返回DOS（功能号4CH）
    INT 21H                 ; 触发DOS中断
CODE ENDS
END START                   ; 程序结束，入口为START
```

**运行效果**：AL寄存器最终值为0x70（十进制112）。  
**涉及知识点**：  
- 段定义（`SEGMENT`/`ENDS`）  
- 寄存器寻址（AL/BL）  
- 立即寻址（`MOV AL, 0x30`）  
- 算术指令（`ADD`）  
- 系统调用（`INT 21H`返回DOS）  


### 示例2：10字节数组求和（循环与内存访问）
```asm
; ==============================================
; 功能：计算数组arr中10个字节的和（结果存SUM）
; 数组：arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
; 输出：SUM=55（十进制）
; ==============================================
DATA SEGMENT
    arr DB 1,2,3,4,5,6,7,8,9,10  ; 定义字节数组（DB：Define Byte）
    count EQU $ - arr            ; 计算数组长度（$表示当前地址）,后面的是减号
    SUM DB 0                     ; 存储结果（初始为0）
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA         ; 初始化数据段寄存器
    MOV DS, AX           ; DS指向DATA段（必须通过AX中转）--------这里没懂
    
    MOV CX, count        ; CX=循环次数（10次）
    MOV BX, 0            ; BX=数组索引（初始0）
    MOV AL, 0            ; AL=累加器（初始0）

LOOP_START:
    ADD AL, arr[BX]      ; 寄存器相对寻址：AL += arr[BX]
    INC BX               ; BX自增1（指向下一个元素）
    LOOP LOOP_START      ; CX减1，若CX≠0则跳转LOOP_START

    MOV SUM, AL          ; 保存结果到SUM变量
    MOV AH, 4CH          ; 返回DOS
    INT 21H
CODE ENDS
END START
```

**运行效果**：SUM变量值为0x37（十进制55）。  
**涉及知识点**：  
- 数据段定义（`DATA SEGMENT`）  
- 符号常量（`EQU`定义count）  
- 内存寻址（寄存器相对寻址`arr[BX]`）  
- 循环控制（`LOOP`指令，依赖CX计数器）  
- 数据类型（DB定义字节，DW定义字）  


### 示例3：键盘输入字符并回显（IO操作）
```asm
; ==============================================
; 功能：从键盘输入一个字符（如'A'），并在屏幕上回显
; 输入：键盘按下任意键（ASCII码存入AL）
; 输出：屏幕显示相同字符
; ==============================================
CODE SEGMENT
    ASSUME CS:CODE
START:
    ; 输入字符（DOS功能号01H）
    MOV AH, 01H          ; 设置功能号：读取字符并回显
    INT 21H              ; 触发DOS中断，输入字符存入AL
    
    ; 输出字符（DOS功能号02H）
    MOV DL, AL           ; DL=要输出的字符（AL来自输入）
    MOV AH, 02H          ; 设置功能号：显示字符
    INT 21H              ; 触发DOS中断，屏幕显示DL中的字符
    
    MOV AH, 4CH          ; 返回DOS
    INT 21H
CODE ENDS
END START
```

**运行效果**：输入'A'，屏幕显示'A'。  
**涉及知识点**：  
- DOS中断（`INT 21H`）的功能调用（01H/02H）  
- 输入输出寄存器（输入：AL；输出：DL）  
- 功能号设置（`MOV AH, 功能号`）  


### 示例4：1到5的阶乘计算（子程序调用）
```asm
; ==============================================
; 功能：计算5!（5的阶乘），结果存入RESULT
; 公式：5! = 5×4×3×2×1 = 120
; 输出：RESULT=120（0x78）
; ==============================================
DATA SEGMENT
    RESULT DW 0          ; 定义字变量（DW：Define Word）
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    
    MOV AX, 5            ; 参数：计算5的阶乘
    CALL FACTORIAL       ; 调用子程序，结果存AX
    MOV RESULT, AX       ; 保存结果到RESULT
    
    MOV AH, 4CH
    INT 21H

; ==============================================
; 子程序：计算n!（n≤12，避免溢出）
; 输入：AX=参数n（如5）
; 输出：AX=结果n!
; ==============================================
FACTORIAL PROC           ;PROCess  :处理
    PUSH CX              ; 保护CX寄存器（现场保存）
    MOV CX, AX           ; CX=循环次数（初始为n）
    MOV BX, 1            ; BX=累积器（初始为1）

FACT_LOOP:
    MUL BX               ; AX = AX × BX（无符号乘法）
    MOV BX, AX           ; BX=当前乘积（用于下次乘法）
    DEC CX               ; CX减1
    JNZ FACT_LOOP        ; 若CX≠0，继续循环(手动实现while循环),如果是使用loop,则是for循环
    
    POP CX               ; 恢复CX寄存器（现场恢复）
    RET                  ; 返回主程序
FACTORIAL ENDP

CODE ENDS
END START
```

**运行效果**：RESULT变量值为0x78（十进制120）。  
**涉及知识点**：  
- 子程序定义（`PROC`/`ENDP`）  
- 现场保护（`PUSH`/`POP`寄存器）  
- 乘法指令（`MUL`，无符号乘法）  
- 条件跳转（`JNZ`：非零跳转）  


### 示例5：十六进制转十进制字符串（综合应用）
```asm
; ==============================================
; 功能：将16位十六进制数（如0x1234）转为十进制字符串（"4660"）
; 输入：AX=0x1234
; 输出：屏幕显示"4660"
; ==============================================
DATA SEGMENT
    BUFFER DB 5 DUP(0)   ; 存放十进制字符串（最多5位）
    STRING DB '(null)$'  ; 输出字符串（以$结尾）
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX           ;这里必须要中转,因为assume是伪码
    MOV AX, 0x1234       ; 待转换的十六进制数
    
    ; 调用转换子程序
    LEA SI, BUFFER       ; SI指向BUFFER（存放转换结果）
    CALL HEX_TO_DEC      ; 转换AX为十进制字符串
    
    ; 显示结果（DOS功能号09H）
    LEA DX, STRING       ; DX指向待显示的字符串
    MOV AH, 09H
    INT 21H
    
    MOV AH, 4CH
    INT 21H

; ==============================================
; 子程序：将AX中的16位十六进制数转为十进制字符串
; 输入：AX=待转换的数，SI=结果缓冲区地址
; 输出：STRING变量为十进制字符串（如"4660"）
; ==============================================
HEX_TO_DEC PROC
    PUSH AX              ; 保护寄存器
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV CX, 0            ; 计数器（记录位数）
    MOV BX, 10           ; 除数（十进制基数）

DIV_LOOP:
    XOR DX, DX           ; DX清零（AX:DX组成32位被除数）
    DIV BX               ; AX = AX/BX（商），DX=余数（0-9）
    PUSH DX              ; 保存余数（逆序）
    INC CX               ; 位数加1
    CMP AX, 0            ; 商是否为0？
    JNE DIV_LOOP         ; 未转换完则继续

    ; 将栈中余数转为ASCII字符（0x30~0x39）
    LEA DI, BUFFER       ; DI指向BUFFER
POP_LOOP:
    POP DX               ; 弹出余数（逆序→顺序）
    ADD DL, 0x30         ; 转为ASCII（0→'0'，9→'9'）
    MOV [DI], DL         ; 存入缓冲区
    INC DI               ; DI指向下一个位置
    LOOP POP_LOOP        ; CX减1，直到所有位处理完毕

    ; 构造以$结尾的字符串
    MOV [DI], BYTE PTR '$'  ; 字符串结束符
    LEA SI, BUFFER       ; SI指向转换后的字符串
    LEA DI, STRING       ; DI指向目标字符串
COPY_LOOP:
    MOV AL, [SI]         ; 复制字符
    MOV [DI], AL
    INC SI
    INC DI
    CMP AL, '$'          ; 是否复制完成？
    JNE COPY_LOOP

    POP DX               ; 恢复寄存器
    POP CX
    POP BX
    POP AX
    RET
HEX_TO_DEC ENDP

CODE ENDS
END START
```

**运行效果**：屏幕显示"4660"。  
**涉及知识点**：  
- 除法指令（`DIV`，无符号除法）  
- 栈操作（`PUSH`/`POP`实现逆序存储）  
- ASCII码转换（数字→字符：加0x30）  
- 字符串操作（复制、结束符$）  


### 知识点总结表
| 程序示例         | 核心知识点                                                                 |
|------------------|--------------------------------------------------------------------------|
| 两数相加         | 段定义、寄存器/立即寻址、算术指令（ADD）、系统调用（INT 21H）                   |
| 数组求和         | 数据段变量、寄存器相对寻址、循环控制（LOOP）、计数器（CX）                      |
| 字符输入输出      | DOS中断功能号（01H/02H）、输入输出寄存器（AL/DL）                              |
| 阶乘计算（子程序）| 子程序定义（PROC/ENDP）、现场保护（PUSH/POP）、乘法指令（MUL）、参数传递               |
| 十六进制转十进制  | 除法指令（DIV）、栈的逆序存储、ASCII码转换、字符串操作（结束符$）、内存拷贝                  |


### 学习建议
1. **从基础指令开始**：先掌握`MOV`（数据传送）、`ADD`/`SUB`（加减）、`LOOP`（循环）等核心指令。  
2. **理解寄存器作用**：AX（累加器）、BX（基址）、CX（计数器）、DX（数据）是最常用的4个16位寄存器。  
3. **熟悉寻址方式**：立即寻址（直接用数值）→ 寄存器寻址（用寄存器值）→ 内存寻址（访问变量）逐步深入。  
4. **调试工具使用**：用Debug或DOSBox+MASM环境调试，观察寄存器和内存变化（如`R`查看寄存器，`D`查看内存）。  
5. **多写小项目**：从简单的加减到循环、IO，再到综合转换程序，逐步提升复杂度。