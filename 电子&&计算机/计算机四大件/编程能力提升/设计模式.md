

### **设计模式知识树**
#### **一、创建型模式（对象创建机制）**  
**核心目标**：分离对象创建逻辑，解耦对象使用与创建过程。  

1. **单例模式（Singleton）**  
   - **定义**：确保一个类只有一个实例，且提供全局访问点。  
   - **场景**：日志管理器、线程池、配置中心（如Spring的`ApplicationContext`）。  
   - **实现关键点**：私有构造函数、静态实例、线程安全控制（DCL双重检查锁定）。  

2. **工厂模式（Factory Pattern）**  
   - **简单工厂（非GOF）**：一个工厂类根据参数创建不同子类对象（如根据类型生成不同动物）。  
   - **工厂方法**：定义一个创建对象的接口，由子类决定实例化哪个类（如汽车工厂的比亚迪工厂、特斯拉工厂）。  
   - **抽象工厂**：创建相关或依赖对象的家族，而无需指定具体类（如生产手机的同时生产配套充电器，华为/小米各自的产品线）。  

3. **建造者模式（Builder）**  
   - **定义**：将复杂对象的构建过程与表示分离，允许相同构建过程创建不同表示。  
   - **场景**：创建配置复杂的对象（如SQL查询构建器、StringBuilder），或需要分步构造的对象（如用户注册信息：基本信息→验证→权限设置）。  

4. **原型模式（Prototype）**  
   - **定义**：通过复制现有对象创建新对象，避免重复初始化逻辑。  
   - **场景**：批量创建相似对象（如游戏中复制NPC角色），需实现`Cloneable`接口或使用序列化深拷贝。  


#### **二、结构型模式（对象/类结构设计）**  
**核心目标**：优化类或对象的组合方式，简化结构并提升扩展性。  

1. **适配器模式（Adapter）**  
   - **类适配器**：通过继承适配不兼容接口（如将圆插头适配到方插座）。  
   - **对象适配器**：通过组合适配不兼容接口（更常用，如Java中用`Target`接口包装`Adaptee`对象）。  
   - **场景**：兼容旧系统接口、第三方库对接（如Spring MVC将Servlet请求适配为`HandlerAdapter`）。  

2. **桥接模式（Bridge）**  
   - **定义**：将抽象部分与实现部分分离，使两者可独立变化。  
   - **场景**：多维度扩展场景（如手机品牌+操作系统：华为手机可运行Android/iOS，通过桥接分离品牌与系统）。  

3. **组合模式（Composite）**  
   - **定义**：将对象组合成树形结构，表示“部分-整体”层次，统一处理单个对象和组合对象。  
   - **场景**：文件系统（文件+文件夹）、组织结构（员工+部门），需实现`Component`接口统一操作。  

4. **装饰模式（Decorator）**  
   - **定义**：动态添加对象功能，通过包装器（Wrapper）模式实现，比继承更灵活。  
   - **场景**：咖啡调味（基础咖啡+牛奶+糖浆，每层装饰添加功能）、IO流（`BufferedInputStream`装饰`InputStream`）。  

5. **外观模式（Facade）**  
   - **定义**：为复杂子系统提供统一接口，简化外部调用（如电脑开机：隐藏主板、CPU、硬盘等细节，暴露`turnOn()`接口）。  
   - **场景**：微服务网关、框架API封装（如MyBatis的`SqlSession`简化数据库操作）。  

6. **享元模式（Flyweight）**  
   - **定义**：共享对象以减少内存占用，区分内部状态（不可变，如字符形状）和外部状态（可变，如字符颜色）。  
   - **场景**：文本渲染（共享字符对象，不同位置颜色不同）、数据库连接池（复用连接对象）。  

7. **代理模式（Proxy）**  
   - **静态代理**：手动创建代理类（如明星经纪人代理明星接活动）。  
   - **动态代理**：运行时生成代理类（如Java的`InvocationHandler`、CGLIB，用于AOP实现日志/事务拦截）。  
   - **场景**：远程代理（RPC调用）、缓存代理（先查缓存再查数据库）、保护代理（权限控制）。  


#### **三、行为型模式（对象交互与职责分配）**  
**核心目标**：优化对象间的通信方式，解耦行为逻辑与职责。  

1. **策略模式（Strategy）**  
   - **定义**：定义算法族，封装每个算法，使其可互换（如支付方式：支付宝/微信支付/银联，策略接口`PayStrategy`）。  
   - **场景**：算法动态切换（如排序算法、促销策略），避免多重`if-else`。  

2. **模板方法模式（Template Method）**  
   - **定义**：在抽象类中定义算法骨架，具体步骤由子类实现（如论文写作模板：摘要→正文→结论，正文内容由学生自定义）。  
   - **场景**：框架设计（如Spring的`JdbcTemplate`定义模板，子类实现具体查询）。  

3. **观察者模式（Observer）**  
   - **定义**：对象间建立订阅关系，当主题（Subject）变化时，通知所有观察者（Observer）。  
   - **场景**：消息推送（微信公众号关注者）、事件监听（GUI按钮点击事件）、Spring的`ApplicationEvent`机制。  

4. **迭代器模式（Iterator）**  
   - **定义**：提供统一接口遍历集合元素，封装遍历逻辑（如Java的`Iterator`接口，支持`next()`/`hasNext()`）。  
   - **场景**：自定义集合遍历（如链表、树结构），分离遍历与集合实现。  

5. **责任链模式（Chain of Responsibility）**  
   - **定义**：请求处理者连成链，请求沿链传递直至处理（如审批流程：组长→经理→总监，每个节点决定是否处理或传递）。  
   - **场景**：权限校验、日志过滤（如日志级别过滤链：DEBUG→INFO→ERROR）。  

6. **命令模式（Command）**  
   - **定义**：将请求封装为对象，支持撤销、排队等操作（如GUI的“撤销”功能，将操作记录为`Command`对象）。  
   - **场景**：事务日志（记录操作以便回滚）、游戏按键绑定（按钮对应不同命令对象）。  

7. **备忘录模式（Memento）**  
   - **定义**：保存对象状态以便恢复（如游戏存档、编辑器的撤销功能，通过`Memento`对象存储状态）。  
   - **关键点**：Originator（原发器）创建备忘录，Caretaker（管理者）负责存储。  

8. **状态模式（State）**  
   - **定义**：对象行为随状态改变而变化，将状态封装为独立类（如电梯状态：运行/停止/故障，不同状态下按钮响应不同）。  
   - **场景**：状态机设计（订单状态：待支付→已支付→已发货→完成）。  

9. **访问者模式（Visitor）**  
   - **定义**：将数据结构与操作分离，允许新增操作不修改原有数据结构（如统计文件系统中文件大小，访问者遍历文件并计算）。  
   - **场景**：数据结构固定但操作多变（如XML解析器、编译器的语义分析）。  

10. **中介者模式（Mediator）**  
    - **定义**：用中介者对象封装对象间交互，避免直接依赖（如聊天室，用户不直接通信，通过服务器中介转发消息）。  
    - **场景**：GUI组件交互（按钮、文本框通过窗口中介通信）、分布式系统中的消息中间件。  

11. **解释器模式（Interpreter）**  
    - **定义**：定义语言的文法，并用解释器来解释语言中的句子（如正则表达式引擎、数学表达式解析`a + b * c`）。  
    - **场景**：自定义语言解析（如SQL解析器、脚本引擎），实际应用较少，多被框架替代。  


### **设计模式核心思想总结**  
- **创建型**：分离“创建”与“使用”，避免紧耦合。  
- **结构型**：优化“组合”方式，简化复杂结构。  
- **行为型**：解耦“交互”逻辑，提升扩展性与灵活性。  

通过理解不同模式的适用场景，可在设计中选择最合适的方案，避免过度设计或滥用模式。