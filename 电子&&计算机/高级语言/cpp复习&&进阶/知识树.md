
# 面向对象C++知识树（人话版，含C对比+易错点+C++11新特性）


## 一、C++ vs C：从过程到对象的进化
### （一）核心差异对比
| **特性**   | C             | C++                        | 人话解释（为什么重要）                                           |
| -------- | ------------- | -------------------------- | ----------------------------------------------------- |
| **编程范式** | 面向过程（函数驱动）    | 面向对象（类+对象驱动）               | C++像“万物皆可打包”，比如把“人”封装成类，包含年龄/行为；C像“裸奔”，年龄用变量，行为用函数单独写 |
| **数据安全** | 结构体无访问控制      | 类有public/protected/private | C++可以让类的内部数据（如人的银行卡密码）对外隐藏，只开放必要接口（如查询余额）             |
| **类型检查** | 弱类型（隐式转换宽松）   | 强类型（新增explicit关键字）         | C++强制要求显式类型转换，避免“把猫当狗撸”的低级错误（比如int转自定义类必须用构造函数）       |
| **内存管理** | 手动malloc/free | 新增new/delete，配合智能指针        | C++可以自动管理内存（如用unique_ptr代替手动free），妈妈再也不用担心我忘记释放内存了    |
| **代码复用** | 函数复用          | 类继承+模板泛型                   | C++可以让“狗”继承“动物”类，复用动物的“呼吸”方法，再自定义“汪汪叫”；C只能重写函数        |

### （二）C++特有的“语法糖”
1. **结构体升级为类**  
   - C：`struct Person { int age; };` 只能存数据  
   - C++：`class Person { public: int age; void speak() { cout << "Hello"; } };` 数据+行为打包  
   - **易混淆点**：结构体和类默认访问权限不同（struct默认public，class默认private）

2. **输入输出进化**  
   - C：`printf("age=%d", a);` 需要手动控制格式  
   - C++：`cout << "age=" << a;` 自动类型推导，支持自定义类输出（重载<<运算符）

3. **函数增强**  
   - 函数重载：C不允许同名函数，C++允许（靠参数类型/个数区分，如`void f(int)`和`void f(double)`）  
   - 默认参数：`void f(int a=10)` 调用时可省略参数，C没有此特性  


## 二、面向对象三大特性：封装、继承、多态
### （一）封装：把数据和操作“打包成快递”
#### 核心内容  
1. **类的定义**  
   ```cpp
   class Car {
   private:
       int speed; // 私有数据，外部不能直接访问
   public:
       void setSpeed(int s) { speed = s; } // 公有接口，控制数据修改
       int getSpeed() { return speed; }
   };
   ```  
2. **对象创建**  
   - 栈对象：`Car myCar;` 自动分配释放内存  
   - 堆对象：`Car* pCar = new Car(); delete pCar;`（C++11后推荐用智能指针`unique_ptr<Car> pCar(new Car);`）

#### C对比  
C没有类，只能用结构体+函数指针模拟封装，代码冗余且不安全（比如结构体数据可被任意修改）

#### 易混淆点  
- **成员初始化列表**：  
  ```cpp
  Car(int weight) : weight(weight) {} // 推荐用初始化列表，比在构造函数体内赋值更高效
  ```  
  错误写法：`Car(int weight) { weight = weight; }` 实际是用形参覆盖成员变量，应写成`this->weight = weight;`

### （二）继承：“儿子继承爸爸的财产”
#### 核心内容  
1. **继承方式**  
   - 公有继承：`class ElectricCar : public Car` 儿子继承爸爸的公有/保护成员，访问权限不变  
   - 私有继承：儿子的子类无法访问爸爸的成员（很少用）  
2. **构造/析构顺序**  
   - 先构造父类，再构造子类；析构顺序相反（父类析构函数建议声明为虚函数，避免子类析构不彻底）

#### C对比  
C没有继承，代码复用靠复制粘贴（比如写电动车代码时，重复写汽车的加速/刹车函数）

#### 易混淆点  
- **菱形继承（钻石问题）**：  
  ```cpp
  class Animal {};
  class Dog : public Animal {};
  class Husky : public Dog, public Animal {}; // 错误！Animal被继承两次
  ```  
  解决：虚继承`class Dog : virtual public Animal`，确保父类只存在一份实例

### （三）多态：“同样的动作，不同的表现”
#### 核心内容  
1. **静态多态（编译期确定）**  
   - 函数重载、模板：`template <typename T> void f(T t) { ... }` 编译时根据类型生成不同代码  
2. **动态多态（运行期确定）**  
   - 虚函数：父类声明`virtual void speak() = 0;` 纯虚函数（抽象类，不能实例化）  
     子类重写`void speak() override { cout << "Woof"; }`（C++11新增`override`关键字，强制检查重写正确性）  
   - 基类指针指向子类对象：`Animal* a = new Dog(); a->speak();` 调用子类实现

#### C对比  
C没有多态，只能靠函数指针+类型判断模拟（比如用switch判断类型，再调用对应函数，代码丑且易错）

#### 易混淆点  
- **虚函数表（VTable）**：  
  每个包含虚函数的类都会生成一个VTable，存储虚函数地址；子类重写虚函数时，替换对应位置的函数指针  
- **动态类型转换**：  
  ```cpp
  Dog* d = dynamic_cast<Dog*>(a); // 安全转换，a确实是Dog*时返回指针，否则返回nullptr
  ```  
  区别于`static_cast`（编译期强制转换，不检查安全性）
- 上面这个就是动态编译和静态编译的区别


## 三、C++11新特性：让代码更简洁安全
### （一）智能指针：自动管理内存的“管家”
| **类型**       | 特点                                                                 | 适用场景                     |
|----------------|----------------------------------------------------------------------|------------------------------|
| `unique_ptr`   | 独占所有权，不可复制，可移动（`u2 = std::move(u1)`）                 | 管理单个资源（如文件句柄）   |
| `shared_ptr`   | 共享所有权，引用计数控制，线程安全（但性能有损耗）                   | 多个对象共享资源             |
| `weak_ptr`     | 弱引用，不影响引用计数，解决循环引用（如`shared_ptr`互相引用导致内存泄漏） | 配合`shared_ptr`使用         |

#### 对比C  
C完全手动管理内存，忘记`free`会导致泄漏；C++11前用`auto_ptr`（已废弃，有所有权转移缺陷）

### （二）Lambda表达式：匿名函数“随手写”
```cpp
// 传统C++函数对象
sort(arr, arr+5, greater<int>());

// Lambda写法（更简洁）
sort(arr, arr+5, [](int a, int b){ return a > b; });
```  
- **捕获列表**：`[=]` 按值捕获外部变量，`[&]` 按引用捕获，`[a, &b]` 单独捕获a（值）和b（引用）  
- **返回类型**：可省略，编译器自动推导（复杂情况需显式声明`-> int { return 0; }`）

### （三）右值引用与移动语义：“偷”数据而不是“复制”
- **左值vs右值**：  
  - 左值：有名字、能取地址（如`int a; a`是左值）  
  - 右值：临时值、不能取地址（如`10`、`a+1`）  
- **移动构造函数**：  
  ```cpp
  String(String&& other) noexcept : data(other.data) { // 偷指针，不复制数据
      other.data = nullptr;
  }
  ```  
  作用：避免深拷贝，提升容器插入/赋值性能（如`vector<string>`添加元素时，直接转移内存所有权）

### （四）其他实用特性  
1. **范围for循环**：  
   ```cpp
   vector<int> arr = {1,2,3};
   for (int x : arr) { cout << x; } // 遍历容器更简单，C没有此特性
   ```  
2. **nullptr**：  
   替代C的`NULL`（本质是`((void*)0)`），明确表示空指针，避免与`0`（整数）混淆  
3. **类型推导**：  
   - `auto x = 10;` 自动推导类型为int  
   - `decltype(x)` 获取变量类型（如`decltype(x) y = 20;`）


## 四、C++容易踩的“坑”（易混淆概念）
### （一）指针vs引用
| **特性**       | 指针                                   | 引用                                   | 怎么选？                                      |
|----------------|----------------------------------------|----------------------------------------|---------------------------------------------|
| 定义         | 指向内存地址的变量（可NULL）           | 变量的别名（必须初始化，不能NULL）     | 选引用：需要“别名”时（函数参数避免拷贝）    |
| 空值         | 可以指向NULL                            | 必须指向有效对象                       | 选指针：需要“可空”或“指向不同对象”时        |
| 大小         | 4/8字节（取决于平台）                  | 同所引用对象的大小                     |                                             |

### （二）const的N种写法
1. **const修饰指针**  
   - `const int* p`：指针指向的内容不可变（“常量指针”）  
   - `int* const p`：指针本身不可变（“指针常量”）  
   - `const int* const p`：两者都不可变  
2. **const成员函数**  
   ```cpp
   int getAge() const { return age; } // 保证函数不修改成员变量（this指针为const类型）
   ```  
   错误：在const成员函数中修改成员变量（除非成员用`mutable`修饰）

### （三）重载vs重写vs隐藏
| **概念**       | 作用范围       | 条件                                   | 示例                                      |
|----------------|----------------|----------------------------------------|-----------------------------------------|
| 重载（Overload）| 同一作用域     | 函数名相同，参数列表不同               | `void f(int)` 和 `void f(double)`        |
| 重写（Override）| 父子类         | 虚函数，函数名、参数、返回值完全相同  | 子类重写父类的虚函数`virtual void f()`   |
| 隐藏（Hide）   | 父子类         | 子类函数覆盖父类同名函数（无论参数）  | 父类`void f(int)`，子类`void f()` 会隐藏父类版本 |


## 五、扩展内容：C++进阶知识
### （一）模板与泛型编程
1. **函数模板**  
   ```cpp
   template <typename T> T max(T a, T b) { return a > b ? a : b; }
   ```  
   编译时根据参数类型生成具体函数（如`max<int>`、`max<double>`）  
2. **类模板**  
   ```cpp
   template <typename T> class Vector { /* ... */ };
   Vector<int> vec; // 实例化为int类型的Vector
   ```  
3. **模板特化**  
   为特定类型定制实现（如`template <> class Vector<bool>` 优化布尔向量存储）

### （二）STL容器：C++的“万能工具箱”
| **容器类型**   | 特点                                                                 | 典型应用                     |
|----------------|----------------------------------------------------------------------|------------------------------|
| 序列容器       | `vector`（动态数组，尾插高效）、`list`（双向链表，任意位置插入高效） | 数据存储，如学生信息管理     |
| 关联容器       | `map`（键值对，红黑树实现，有序）、`unordered_map`（哈希表，无序）  | 字典查找，如单词频率统计     |
| 容器适配器     | `stack`（栈，后进先出）、`queue`（队列，先进先出）                   | 算法辅助（如广度优先搜索）   |

### （三）RAII：资源管理最佳实践
- **概念**：利用对象生命周期自动管理资源（如文件、锁、网络连接）  
- **示例**：  
  ```cpp
  class File {
  public:
      File(const string& path) { fopen(path); }
      ~File() { fclose(); } // 析构函数释放资源
  }; // 离开作用域时自动关闭文件，避免忘记释放
  ```  
  对比C：手动`fopen`+`fclose`，容易因异常导致资源泄漏

### （四）C++与OOP的“反模式”
1. **过度设计**：为了用类而用类，比如把简单的数学函数封装成“MathTool”类  
2. **虚函数滥用**：非多态场景使用虚函数（如简单的getter/setter），增加性能开销  
3. **依赖倒置原则违反**：子类依赖具体父类实现，而非抽象接口（正确做法：依赖纯虚函数接口）


## 六、核心知识脉络与学习建议
### （一）知识树脉络
```
C++面向对象
├─ C与C++对比（语法糖+范式升级）
├─ 三大特性（封装/继承/多态的原理与实践）
│  ├─ 封装：类+访问控制+构造函数
│  ├─ 继承：公有/私有继承+菱形问题解决
│  └─ 多态：虚函数表+动态绑定+override关键字
├─ C++11新特性（智能指针/Lambda/移动语义）
├─ 易混淆概念（指针vs引用/const用法/重载vs重写）
└─ 扩展内容（模板/STL/RAII/反模式）
```

### （二）学习建议
1. **从对比中记忆**：每次学C++特性时，想想C是怎么做的，为什么C++要这么设计（比如智能指针解决C的内存泄漏问题）  
2. **动手写代码**：  
   - 练习多态：定义“Shape”父类（纯虚函数`area()`），派生“Circle”“Rectangle”类，用基类指针调用  
   - 体验移动语义：写一个包含动态数组的类，实现移动构造函数，用`vector`测试性能差异  
3. **避开陷阱**：  
   - 永远给基类析构函数加`virtual`，避免子类析构不完整  
   - 优先用`nullptr`代替`NULL`，防止空指针错误  


## 总结
通过以上知识树，你将全面掌握C++面向对象的核心概念、与C的本质区别、易混淆点及现代C++特性。记住：C++的核心是“零成本抽象”——用面向对象提升开发效率，同时保持接近C的性能，关键是在合适的场景选择合适的工具（比如能用`vector`就别手动管理数组，能用智能指针就别用原始指针）。

[[异常和模板]]
[[STL&&可调用对象]]
[[c++新特性]]
[[c++复习题]]
[[STL补充练习]]
[[范围for和lambda]]
[[多线程、多进程]]
[[流控制语句&&文件]]